{
  "version": 3,
  "file": "main.js",
  "sources": [
    "../../node_modules/@jsenv/pwa/src/internal/listenEvent.js",
    "../../node_modules/@jsenv/pwa/src/displayModeStandalone.js",
    "../../node_modules/@jsenv/pwa/src/add-to-home-screen.js",
    "../../node_modules/@jsenv/core/helpers/babel/arrayLikeToArray/arrayLikeToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/toConsumableArray/toConsumableArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/arrayWithoutHoles/arrayWithoutHoles.js",
    "../../node_modules/@jsenv/core/helpers/babel/iterableToArray/iterableToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/unsupportedIterableToArray/unsupportedIterableToArray.js",
    "../../node_modules/@jsenv/core/helpers/babel/nonIterableSpread/nonIterableSpread.js",
    "../../node_modules/@jsenv/pwa/src/navigatorController.js",
    "../../node_modules/@jsenv/pwa/src/internal/createSignal.js",
    "../../node_modules/@jsenv/pwa/src/internal/sendMessageUsingChannel.js",
    "../../src/dom.js",
    "../../src/add-to-home-screen.js",
    "../../src/service-worker-update.js",
    "../../node_modules/@jsenv/pwa/src/listenAppInstalled.js",
    "../../src/service-worker-registration.js",
    "../../node_modules/@jsenv/core/helpers/babel/objectWithoutProperties/objectWithoutProperties.js",
    "../../node_modules/@jsenv/core/helpers/babel/objectWithoutPropertiesLoose/objectWithoutPropertiesLoose.js",
    "../../node_modules/@jsenv/core/helpers/babel/defineProperty/defineProperty.js",
    "../../node_modules/@jsenv/core/helpers/babel/objectSpread2/objectSpread2.js",
    "../../src/game/bloc.draw.js",
    "../../src/game/bloc.js",
    "../../src/game/geometry.js",
    "../../src/game/bloc.effects.js",
    "../../src/game/game.js",
    "../../src/game/bloc.updates.js",
    "../../src/game.constant.js",
    "../../src/helper/dom.js",
    "../../src/interaction/keyboard.js",
    "../../src/gridix.js"
  ],
  "sourcesContent": [
    "export const listenEvent = (objectWithEventEmitter, event, callback) => {\n  objectWithEventEmitter.addEventListener(event, callback)\n  return () => {\n    objectWithEventEmitter.removeEventListener(event, callback)\n  }\n}\n",
    "/**\n * displayModeStandalone can be used to know the current displayMode of\n * our web page is standalone (PWA)\n */\n\nexport const displayModeStandalone = {\n  get: () => window.navigator.standalone || window.matchMedia(\"(display-mode: standalone)\").matches,\n  listen: (callback) => {\n    const media = window.matchMedia(\"(display-mode: standalone)\")\n    media.addListener(callback)\n    return () => {\n      media.removeListener(callback)\n    }\n  },\n}\n",
    "/**\n  The following scenario is working:\n\n  - user click install button -> browser shows add to home screen prompt\n  - user click cancel on browser prompt\n  - user click again install button -> browser shows again add to home screen prompt\n\n  It's very easy to break this so that subsequent click does nothing.\n  Nothing means browser always returns a \"dimissed\" user choice without asking user.\n  I suspect chrome is trying to prevent malicious script to annoy user\n  by calling prompt() many times.\n\n  It's currently working because we don't hide beforeinstallpromptEvent behind a function.\n  It would be hidden behind a function if we put it into react state or\n  just by using a curried funciton like:\n\n  beforeinstallpromptEvent\n  const curriedFunction = () => {\n    beforeinstallpromptEvent.prompt()\n  }\n\n  If we do so, chrome will always dismiss subsequent click on install button. (until page is reloaded).\n  To avoid that we store the event on window.beforeinstallpromptEvent.\n*/\n\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { listenAppInstalled } from \"./listenAppInstalled.js\"\nimport { displayModeStandalone } from \"./displayModeStandalone.js\"\n\nexport const listenAddToHomescreenAvailable = (callback) => {\n  let availablePrevious\n  let appInstalledEvent = false\n  const checkAvailable = ({\n    beforeinstallpromptEventAvailableOnWindow,\n    displayModeIsStandalone,\n  }) => {\n    const available = addToHomescreenAvailableGetter({\n      beforeinstallpromptEventAvailableOnWindow,\n      displayModeIsStandalone,\n      appInstalledEvent,\n    })\n    if (available !== availablePrevious) {\n      availablePrevious = available\n      callback(available)\n    }\n  }\n\n  checkAvailable({\n    beforeinstallpromptEventAvailableOnWindow: beforeinstallpromptEventAvailableOnWindowGetter(),\n    displayModeIsStandalone: displayModeStandalone.get(),\n  })\n\n  const removeBeforeInstallPromptListener = listenBeforeInstallPrompt(\n    (beforeinstallpromptEvent) => {\n      window.beforeinstallpromptEvent = beforeinstallpromptEvent\n      checkAvailable({\n        beforeinstallpromptEventAvailableOnWindow: true,\n        displayModeIsStandalone: displayModeStandalone.get(),\n      })\n    },\n  )\n\n  const removeDisplayModeListener = displayModeStandalone.listen(() => {\n    checkAvailable({\n      beforeinstallpromptEventAvailableOnWindow: beforeinstallpromptEventAvailableOnWindowGetter(),\n      displayModeIsStandalone: displayModeStandalone.get(),\n    })\n  })\n\n  const removeAppInstalledListener = listenAppInstalled(() => {\n    // prompt \"becomes\" unavailable if user installs app\n    // it can happen if user installs app manually from browser toolbar\n    // in that case there is no point showing the install\n    // button in the ui\n    appInstalledEvent = true\n    checkAvailable({\n      beforeinstallpromptEventAvailableOnWindow: beforeinstallpromptEventAvailableOnWindowGetter(),\n      displayModeIsStandalone: displayModeStandalone.get(),\n    })\n  })\n\n  return () => {\n    removeBeforeInstallPromptListener()\n    removeDisplayModeListener()\n    removeAppInstalledListener()\n  }\n}\n\nexport const promptAddToHomescreen = async () => {\n  if (!window.beforeinstallpromptEvent) {\n    console.warn(`cannot promptAddToHomescreen: window.beforeinstallpromptEvent is missing`)\n    return false\n  }\n\n  window.beforeinstallpromptEvent.prompt()\n  const choiceResult = await window.beforeinstallpromptEvent.userChoice\n  if (choiceResult.outcome === \"accepted\") {\n    return true\n  }\n  return false\n}\n\nconst beforeinstallpromptEventAvailableOnWindowGetter = () => {\n  return Boolean(window.beforeinstallpromptEvent)\n}\n\nconst addToHomescreenAvailableGetter = ({\n  beforeinstallpromptEventAvailableOnWindow,\n  displayModeIsStandalone,\n  appInstalledEvent,\n}) => {\n  if (!beforeinstallpromptEventAvailableOnWindow) {\n    return false\n  }\n  if (displayModeIsStandalone) {\n    return false\n  }\n  if (appInstalledEvent) {\n    return false\n  }\n  return true\n}\n\nconst listenBeforeInstallPrompt = (callback) => listenEvent(window, \"beforeinstallprompt\", callback)\n",
    "/* eslint-disable no-eq-null, eqeqeq */\nexport default function arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length\n  var arr2 = new Array(len)\n  for (var i = 0; i < len; i++) arr2[i] = arr[i]\n  return arr2\n}\n",
    "import arrayWithoutHoles from \"../arrayWithoutHoles/arrayWithoutHoles.js\"\nimport iterableToArray from \"../iterableToArray/iterableToArray.js\"\nimport unsupportedIterableToArray from \"../unsupportedIterableToArray/unsupportedIterableToArray.js\"\nimport nonIterableSpread from \"../nonIterableSpread/nonIterableSpread.js\"\n\nexport default (arr) =>\n  arrayWithoutHoles(arr) ||\n  iterableToArray(arr) ||\n  unsupportedIterableToArray(arr) ||\n  nonIterableSpread()\n",
    "import arrayLikeToArray from \"../arrayLikeToArray/arrayLikeToArray.js\"\n\n// eslint-disable-next-line consistent-return\nexport default (arr) => {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr)\n}\n",
    "// eslint-disable-next-line consistent-return\nexport default (iter) => {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter)\n}\n",
    "/* eslint-disable consistent-return */\nimport arrayLikeToArray from \"../arrayLikeToArray/arrayLikeToArray.js\"\n\nexport default function unsupportedIterableToArray(o, minLen) {\n  if (!o) return\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen)\n  var n = Object.prototype.toString.call(o).slice(8, -1)\n  if (n === \"Object\" && o.constructor) n = o.constructor.name\n  if (n === \"Map\" || n === \"Set\") return Array.from(o)\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n    return arrayLikeToArray(o, minLen)\n}\n",
    "export default () => {\n  throw new TypeError(\n    \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\",\n  )\n}\n",
    "// do not forget error handling: https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/onerror\n\nimport { createSignal } from \"./internal/createSignal.js\"\nimport { listenEvent } from \"./internal/listenEvent.js\"\nimport { sendMessageUsingChannel } from \"./internal/sendMessageUsingChannel.js\"\n\nconst serviceWorkerAPI = window.navigator.serviceWorker\n\nexport const canUseServiceWorker =\n  Boolean(serviceWorkerAPI) && document.location.protocol === \"https:\"\n\n// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration\nlet registrationPromise = null\nlet serviceWorker = null\nconst serviceWorkerSetter = (worker) => {\n  serviceWorker = worker\n}\n\nlet serviceWorkerUpdating = null\nconst serviceWorkerUpdatingChangeSignal = createSignal()\nconst serviceWorkerUpdatingSetter = (worker) => {\n  if (serviceWorkerUpdating && serviceWorkerUpdating === worker) {\n    // we already know about this worker, no need to listen state changes.\n    // it happens for manual updates where we bot detect it\n    // from registration.update() return value\n    // and \"updatefound\" event\n    console.log(\"we already know this worker is updating\")\n    return\n  }\n  if (worker) {\n    console.log(`found a worker updating (worker state is: ${worker.state})`)\n  } else {\n    console.log(`worker update is done`)\n  }\n  serviceWorkerUpdating = worker\n  serviceWorkerUpdatingChangeSignal.emit()\n}\n\nexport const serviceWorkerIsAvailable = () => Boolean(registrationPromise)\n\nexport const registerServiceWorker = (url, { scope } = {}) => {\n  if (!canUseServiceWorker) {\n    return () => {}\n  }\n\n  let unregistered = false\n  let unregister = () => {}\n  let removeUpdateFoundListener = () => {}\n\n  registrationPromise = serviceWorkerAPI.register(url, { scope })\n  ;(async () => {\n    const registration = await registrationPromise\n    unregister = () => {\n      registration.unregister()\n    }\n\n    if (unregistered) {\n      unregister()\n      return\n    }\n\n    const { installing, waiting, active } = registration\n    serviceWorkerSetter(installing || waiting || active)\n    removeUpdateFoundListener = listenEvent(registration, \"updatefound\", () => {\n      console.log(\"browser notifies use an worker is installing\")\n      if (registration.installing === installing) {\n        console.log(`it's not an worker update, it's first time worker registers`)\n        return\n      }\n      serviceWorkerUpdatingSetter(registration.installing)\n    })\n  })()\n\n  return () => {\n    unregistered = true\n    removeUpdateFoundListener()\n    unregister()\n  }\n}\n\n// export const getServiceWorkerState = () => {\n//   if (serviceWorker) {\n//     return serviceWorker.state\n//   }\n//   return null\n// }\n\n// export const listenServiceWorkerState = (callback) => {\n//   let removeStateChangeListener = () => {}\n//   const removeWorkerChangeListener = serviceWorkerChangeSignal.listen(() => {\n//     callback()\n//     removeStateChangeListener = listenEvent(serviceWorker, \"statechange\", callback)\n//   })\n//   return () => {\n//     removeWorkerChangeListener()\n//     removeStateChangeListener()\n//   }\n// }\n\n// For now this function will try to communicate with the old service worker\n// even if new worker is activating or activated.\n// It might not work because, from what I understood, the old worker gets killed\n// by the navigator as soon as the new worker starts to activate.\n// Maybe it should communicate with the new worker as soon as we know\n// updating worker is activating or activated.\n// -> yes\nexport const sendMessageToServiceWorker = (message) => {\n  if (!serviceWorker) {\n    console.warn(`no service worker to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorker, message)\n}\n\nexport const getServiceWorkerUpdate = () => {\n  return serviceWorkerUpdating\n    ? {\n        shouldBecomeNavigatorController: Boolean(serviceWorkerAPI.controller),\n        navigatorWillReload: autoReloadEnabled,\n      }\n    : null\n}\n\nexport const listenServiceWorkerUpdate = (callback) => {\n  return serviceWorkerUpdatingChangeSignal.listen(callback)\n}\n\nexport const checkServiceWorkerUpdate = async () => {\n  if (!registrationPromise) {\n    console.warn(`registerServiceWorker must be called before checkServiceWorkerUpdate can be used`)\n    return false\n  }\n\n  const registration = await registrationPromise\n  // await for the registration promise above can take some time\n  // especially when the service worker is installing for the first time\n  // because it is fetching a lot of urls to put into cache.\n  // In that scenario we might want to display something different ?\n  // Without this UI seems to take ages to check for an update\n  const updateRegistration = await registration.update()\n\n  const { installing } = updateRegistration\n  if (installing) {\n    console.log(\"installing worker found after calling update()\")\n    serviceWorkerUpdatingSetter(installing)\n    return true\n  }\n\n  const { waiting } = updateRegistration\n  if (waiting) {\n    console.log(\"waiting worker found after calling update()\")\n    serviceWorkerUpdatingSetter(waiting)\n    return true\n  }\n\n  console.log(\"no worker found after calling update()\")\n  return false\n}\n\nexport const sendMessageToServiceWorkerUpdate = (message) => {\n  if (!serviceWorkerUpdating) {\n    console.warn(`no service worker updating to send message to`)\n    return undefined\n  }\n  return sendMessageUsingChannel(serviceWorkerUpdating, message)\n}\n\nexport const activateServiceWorkerUpdate = async (params) => {\n  if (!serviceWorkerUpdating) {\n    throw new Error(\"no service worker update to activate\")\n  }\n  return sendSkipWaitingToWorker(serviceWorkerUpdating, params)\n}\n\nconst sendSkipWaitingToWorker = async (\n  worker,\n  { onActivating = () => {}, onActivated = () => {}, onBecomesNavigatorController = () => {} } = {},\n) => {\n  const { state } = worker\n  const waitUntilActivated = () => {\n    return new Promise((resolve) => {\n      const removeStateChangeListener = listenEvent(worker, \"statechange\", () => {\n        if (worker.state === \"activating\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivating()\n        }\n        if (worker.state === \"activated\") {\n          serviceWorkerSetter(serviceWorkerUpdating)\n          onActivated()\n          removeStateChangeListener()\n          resolve()\n        }\n      })\n    })\n  }\n\n  // worker must be waiting (meaning state must be \"installed\")\n  // to be able to call skipWaiting on it.\n  // If it's installing it's an error.\n  // If it's activating, we'll just skip the skipWaiting call\n  // If it's activated, we'll just return early\n  if (state === \"installed\" || state === \"activating\") {\n    if (state === \"installed\") {\n      sendMessageToServiceWorkerUpdate({ action: \"skipWaiting\" })\n    }\n    if (state === \"activating\") {\n      serviceWorkerSetter(serviceWorkerUpdating)\n    }\n    await waitUntilActivated()\n\n    if (serviceWorkerAPI.controller) {\n      const removeControllerChangeListener = listenEvent(\n        serviceWorkerAPI,\n        \"controllerchange\",\n        () => {\n          removeControllerChangeListener()\n          onBecomesNavigatorController()\n          serviceWorkerUpdatingSetter(null)\n          if (autoReloadEnabled) reload()\n        },\n      )\n    } else {\n      serviceWorkerUpdatingSetter(null)\n      if (autoReloadEnabled) reload()\n    }\n    return\n  }\n\n  serviceWorkerSetter(serviceWorkerUpdating)\n  onBecomesNavigatorController()\n  serviceWorkerUpdatingSetter(null)\n  if (autoReloadEnabled) reload()\n}\n\nlet autoReloadEnabled = true\nlet disableAutoReload = () => {}\nexport const autoReloadAfterUpdateIsEnabled = () => autoReloadEnabled\nexport const disableAutoReloadAfterUpdate = () => disableAutoReload()\n\nlet refreshing = false\nconst reload = () => {\n  if (refreshing) {\n    return\n  }\n  refreshing = true\n  window.location.reload()\n}\n\nif (canUseServiceWorker) {\n  const removeControllerChangeListener = listenEvent(serviceWorkerAPI, \"controllerchange\", reload)\n\n  disableAutoReload = () => {\n    autoReloadEnabled = false\n    removeControllerChangeListener()\n  }\n}\n\n// const navigatorIsControlledByAServiceWorker = () => {\n//   return canUseServiceWorker ? Boolean(serviceWorkerAPI.controller) : false\n// }\n\n// const getServiceWorkerControllingNavigator = () => {\n//   return navigatorIsControlledByAServiceWorker() ? serviceWorkerAPI.controller : null\n// }\n",
    "export const createSignal = () => {\n  let listeners = []\n\n  const listen = (callback, { once = false } = {}) => {\n    if (once) {\n      const callbackOriginal = callback\n      callback = (...args) => {\n        stopListening()\n        callbackOriginal(...args)\n      }\n    }\n\n    listeners = [...listeners, callback]\n\n    let removed = false\n    const stopListening = () => {\n      if (removed) return\n      removed = true\n      const listenersWithoutCallback = []\n      let i = listeners.length\n      let searching = true\n      while (i--) {\n        const listenerCandidate = listeners[i]\n        if (searching) {\n          if (listenerCandidate === callback) {\n            searching = false\n          } else {\n            listenersWithoutCallback.push(listenerCandidate)\n          }\n        } else {\n          listenersWithoutCallback.push(listenerCandidate)\n        }\n      }\n      listeners = listenersWithoutCallback\n    }\n    return stopListening\n  }\n\n  const emit = (...args) => {\n    listeners.forEach((listener) => {\n      listener(...args)\n    })\n  }\n\n  return {\n    listen,\n    emit,\n  }\n}\n",
    "// https://felixgerschau.com/how-to-communicate-with-service-workers/\nexport const sendMessageUsingChannel = (objectWithPostMessage, message) => {\n  const { port1, port2 } = new MessageChannel()\n  return new Promise((resolve, reject) => {\n    port1.onmessage = function (event) {\n      if (event.data.status === \"rejected\") {\n        reject(event.data.value)\n      } else {\n        resolve(event.data.value)\n      }\n    }\n    objectWithPostMessage.postMessage(message, [port2])\n  })\n}\n",
    "export const createDOM = (stringContainingHTMLSource) => {\n  const domParser = new DOMParser()\n  const document = domParser.parseFromString(stringContainingHTMLSource, \"text/html\")\n  return document\n}\n",
    "import { listenAddToHomescreenAvailable, promptAddToHomescreen } from \"@jsenv/pwa\"\nimport { createDOM } from \"src/dom.js\"\n\n// on fera une sorte de notif, ou alors de bouton flotant quelque part\nconst addToHomeScreenDocument = createDOM(`<button disabled>Add to home screen</button>`)\nconst buttonAddToHomescreen = addToHomeScreenDocument.querySelector(\"button\")\ndocument.body.appendChild(buttonAddToHomescreen)\n\nbuttonAddToHomescreen.onclick = () => {\n  promptAddToHomescreen()\n}\nlistenAddToHomescreenAvailable((available) => {\n  buttonAddToHomescreen.disabled = !available\n})\n",
    "import {\n  canUseServiceWorker,\n  getServiceWorkerUpdate,\n  listenServiceWorkerUpdate,\n  checkServiceWorkerUpdate,\n  activateServiceWorkerUpdate,\n} from \"@jsenv/pwa\"\nimport { createDOM } from \"src/dom.js\"\n\n// on fera une sorte de notif\nif (canUseServiceWorker) {\n  const serviceWorkerUpdateDocument = createDOM(`\n<button>Check update</button>\n<p></p>\n`)\n  const buttonCheckUpdate = serviceWorkerUpdateDocument.querySelector(\"button\")\n  const paragraph = serviceWorkerUpdateDocument.querySelector(\"p\")\n  document.body.appendChild(buttonCheckUpdate)\n  document.body.appendChild(paragraph)\n\n  buttonCheckUpdate.onclick = async () => {\n    buttonCheckUpdate.disabled = true\n    paragraph.innerHTML = \"checking for update\"\n    const found = await checkServiceWorkerUpdate()\n\n    if (found) {\n      // when update is found, we already know from listenServiceWorkerUpdate\n    } else {\n      buttonCheckUpdate.disabled = false\n      paragraph.innerHTML = \"No update available\"\n    }\n  }\n\n  listenServiceWorkerUpdate(() => {\n    const available = Boolean(getServiceWorkerUpdate())\n    if (available) {\n      paragraph.innerHTML = `Update available <button>Activate update</button>`\n      paragraph.querySelector(\"button\").onclick = async () => {\n        paragraph.querySelector(\"button\").disabled = true\n        await activateServiceWorkerUpdate()\n      }\n    } else {\n      paragraph.innerHTML = \"\"\n    }\n  })\n}\n",
    "/**\n * - User can decide by himself to install the application from the browser toolbar.\n * - Or application code is allowed to prompt user to do so on a user interaction such\n * as after clicking on a button.\n * In these scenarios when user clicks install on that prompt displayed by the browser,\n * browser dispatch an \"appinstalled\" event.\n */\n\nexport const listenAppInstalled = (callback) => {\n  window.addEventListener(\"appinstalled\", callback)\n  return () => {\n    window.removeEventListener(\"appinstalled\", callback)\n  }\n}\n\n// listenAppInstalled(() => {\n//   document.querySelector(\"#install\").disabled = true\n// })\n",
    "import { registerServiceWorker } from \"@jsenv/pwa\"\n\n// wait a bit that browser is less busy to register the service worker\nconst callLater = requestIdleCallback ? requestIdleCallback : requestAnimationFrame\ncallLater(() => {\n  registerServiceWorker(\"/service-worker.js\")\n})\n",
    "import objectWithoutPropertiesLoose from \"../objectWithoutPropertiesLoose/objectWithoutPropertiesLoose.js\"\n\nexport default (source, excluded) => {\n  if (source === null) return {}\n\n  var target = objectWithoutPropertiesLoose(source, excluded)\n  var key\n  var i\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source)\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i]\n      if (excluded.indexOf(key) >= 0) continue\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue\n      target[key] = source[key]\n    }\n  }\n  return target\n}\n",
    "export default (source, excluded) => {\n  if (source === null) return {}\n  var target = {}\n  var sourceKeys = Object.keys(source)\n  var key\n  var i\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i]\n    if (excluded.indexOf(key) >= 0) continue\n    target[key] = source[key]\n  }\n  return target\n}\n",
    "export default (obj, key, value) => {\n  // Shortcircuit the slow defineProperty path when possible.\n  // We are trying to avoid issues where setters defined on the\n  // prototype cause side effects under the fast path of simple\n  // assignment. By checking for existence of the property with\n  // the in operator, we can optimize most of this overhead away.\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    })\n  } else {\n    obj[key] = value\n  }\n  return obj\n}\n",
    "import defineProperty from \"../defineProperty/defineProperty.js\"\n\nexport default function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    // eslint-disable-next-line prefer-rest-params\n    var source = arguments[i] === null ? {} : arguments[i]\n    if (i % 2) {\n      // eslint-disable-next-line no-loop-func\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key])\n      })\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))\n    } else {\n      // eslint-disable-next-line no-loop-func\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key))\n      })\n    }\n  }\n  return target\n}\n\n// This function is different to \"Reflect.ownKeys\". The enumerableOnly\n// filters on symbol properties only. Returned string properties are always\n// enumerable. It is good to use in objectSpread.\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object)\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object)\n    if (enumerableOnly)\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable\n      })\n    // eslint-disable-next-line prefer-spread\n    keys.push.apply(keys, symbols)\n  }\n  return keys\n}\n",
    "export const blocDrawRectangle = (bloc, context) => {\n  context.beginPath()\n  context.rect(bloc.positionX, bloc.positionY, bloc.width, bloc.height)\n  context.closePath()\n\n  applyStyle(context, bloc)\n}\n\nconst applyStyle = (\n  context,\n  {\n    alpha,\n    fillStyle,\n    strokeStyle,\n    image,\n    imageSourceX,\n    imageSourceY,\n    positionX,\n    positionY,\n    width,\n    height,\n  },\n) => {\n  context.globalAlpha = alpha\n  if (fillStyle) {\n    context.fillStyle = fillStyle\n    context.fill()\n  }\n  if (strokeStyle) {\n    context.strokeStyle = strokeStyle\n    context.stroke()\n  }\n  if (image) {\n    // so that the image is constrained with the current path\n    // (for instance a circle)\n    context.clip()\n    context.drawImage(\n      image,\n      imageSourceX,\n      imageSourceY,\n      width,\n      height,\n      positionX,\n      positionY,\n      width,\n      height,\n    )\n  }\n  context.restore()\n}\n\nexport const blocDrawCircle = (bloc, context) => {\n  context.beginPath()\n  context.arc(\n    bloc.positionX + bloc.width / 2,\n    bloc.positionY + bloc.height / 2,\n    bloc.width / 2,\n    0,\n    2 * Math.PI,\n  )\n  context.closePath()\n\n  applyStyle(context, bloc)\n}\n",
    "import { blocDrawRectangle } from \"./bloc.draw.js\"\n\nexport const Bloc = {\n  name: \"anonymous\",\n\n  // position\n  positionX: 0,\n  positionY: 0,\n  zIndex: 0,\n\n  // dimension\n  width: 0,\n  height: 0,\n\n  // physic\n  blocCollidingArray: [],\n  canCollide: false,\n  accelerationX: 0,\n  accelerationY: 0,\n  velocityX: 0,\n  velocityY: 0,\n  friction: 0.01,\n  restitution: 1,\n  mass: 1,\n\n  // styles\n  fillStyle: undefined,\n  strokeStyle: undefined,\n  alpha: 1,\n  image: undefined,\n  imageSourceX: undefined,\n  imageSourceY: undefined,\n\n  updates: {},\n  effects: {},\n  draw: blocDrawRectangle,\n}\n\nexport const mutateBloc = (bloc, mutations) => {\n  Object.assign(bloc, mutations)\n}\n",
    "export const getDistanceBetweenTwoPoints = (firstPoint, secondPoint) => {\n  const horizontalDiff = firstPoint.x - secondPoint.x\n  const verticalDiff = firstPoint.y - secondPoint.y\n  const horizontalDiffSquared = horizontalDiff * horizontalDiff\n  const verticalDiffSquared = verticalDiff * verticalDiff\n  const distance = Math.sqrt(horizontalDiffSquared + verticalDiffSquared)\n\n  return distance\n}\n\nexport const blocToCenterPoint = ({ positionX, positionY, width, height }) => {\n  return {\n    x: positionX + width / 2,\n    y: positionY + height / 2,\n  }\n}\n\nexport const blocCollidesWithBloc = (firstBloc, secondBloc) => {\n  if (!firstBloc.canCollide) {\n    return false\n  }\n\n  if (!secondBloc.canCollide) {\n    return false\n  }\n\n  return rectangleCollidesRectangle(firstBloc, secondBloc)\n}\n\nexport const rectangleCollidesRectangle = (firstRectangle, secondRectangle) => {\n  const firstLeft = firstRectangle.positionX\n  const firstRight = firstLeft + firstRectangle.width\n  const secondLeft = secondRectangle.positionX\n  // first left of second\n  if (firstRight <= secondLeft) {\n    return false\n  }\n\n  const secondRight = secondLeft + secondRectangle.width\n  // first right of second\n  if (firstLeft >= secondRight) {\n    return false\n  }\n\n  const firstTop = firstRectangle.positionY\n  const firstBottom = firstTop + firstRectangle.height\n  const secondTop = secondRectangle.positionY\n  // first above second\n  if (firstBottom <= secondTop) {\n    return false\n  }\n\n  const secondBottom = secondTop + secondRectangle.height\n  // first below second\n  if (firstTop >= secondBottom) {\n    return false\n  }\n\n  return true\n}\n",
    "import { getDistanceBetweenTwoPoints, blocToCenterPoint, blocCollidesWithBloc } from \"./geometry.js\"\nimport { mutateBloc } from \"./bloc.js\"\n\nexport const blocEffectCollisionDetection = {\n  \"collision-detection\": (bloc, { blocs }) => {\n    const blocCollidingArray = blocCollidingArrayGetter(bloc, blocs)\n    return {\n      blocCollidingArray,\n    }\n  },\n}\n\nexport const blocCollidingArrayGetter = (bloc, blocs) => {\n  return blocs.filter((blocCandidate) => {\n    if (blocCandidate === bloc) {\n      return false\n    }\n    return blocCollidesWithBloc(blocCandidate, bloc)\n  })\n}\n\nexport const blocEffectContainer = {\n  container: (blocContainer, { blocs }) => {\n    blocs.forEach((bloc) => {\n      const { velocityX, velocityY } = bloc\n      const blocLeft = bloc.positionX\n      const blocWidth = bloc.width\n      const blocRight = blocLeft + blocWidth\n      const blocTop = bloc.positionY\n      const blocHeight = bloc.height\n      const blocBottom = blocTop + blocHeight\n\n      const containerLeft = blocContainer.positionX\n      const containerTop = blocContainer.positionY\n      const containerWidth = blocContainer.width\n      const containerHeight = blocContainer.height\n      const containerRight = containerLeft + containerWidth\n      const containerBottom = containerTop + containerHeight\n      const containerRestitution = blocContainer.restitution\n\n      const blocMutations = {}\n      if (blocLeft < containerLeft) {\n        blocMutations.positionX = containerLeft\n        blocMutations.velocityX = Math.abs(velocityX) * containerRestitution\n      } else if (blocRight > containerRight) {\n        blocMutations.positionX = containerRight - blocWidth\n        blocMutations.velocityX = -Math.abs(velocityX) * containerRestitution\n      }\n\n      if (blocTop < containerTop) {\n        blocMutations.positionY = containerTop\n        blocMutations.velocityY = Math.abs(velocityY) * containerRestitution\n      } else if (blocBottom > containerBottom) {\n        blocMutations.positionY = containerBottom - blocHeight\n        blocMutations.velocityY = -Math.abs(velocityY) * containerRestitution\n      }\n\n      // la mise a jour de cette position\n      // impacte les autres collisions\n      // ce qui peut les invalider\n      // c'est pourquoi cet effet doit se produire le plus tot possible\n      mutateBloc(bloc, blocMutations)\n    })\n  },\n}\n\nexport const blocEffectCollisionResolution = {\n  \"collision-resolution\": (bloc) => {\n    bloc.blocCollidingArray.forEach((blocColliding) => {\n      const blocCenterPoint = blocToCenterPoint(bloc)\n      const blocCollidingCenterPoint = blocToCenterPoint(blocColliding)\n\n      const centerXDiff = blocCenterPoint.x - blocCollidingCenterPoint.x\n      const centerYDiff = blocCenterPoint.y - blocCollidingCenterPoint.y\n      // Half widths and half heights of the objects\n      const ww2 = bloc.width / 2 + blocColliding.width / 2\n      const hh2 = bloc.height / 2 + blocColliding.height / 2\n\n      // if the x and y vector are less than the half width or half height,\n      // they we must be inside the object, causing a collision\n      if (Math.abs(centerXDiff) < ww2 && Math.abs(centerYDiff) < hh2) {\n        // figures out on which side we are colliding (top, bottom, left, or right)\n        const oX = ww2 - Math.abs(centerXDiff)\n        const oY = hh2 - Math.abs(centerYDiff)\n        if (oX >= oY) {\n          if (centerYDiff > 0) {\n            bloc.positionY += oY\n          } else {\n            bloc.positionY -= oY\n          }\n        } else if (centerXDiff > 0) {\n          bloc.positionX += oX\n        } else {\n          bloc.positionX -= oX\n        }\n      }\n    })\n  },\n}\n\nexport const blocToMoveDirection = ({ velocityX, velocityY }) => {\n  return {\n    movingLeft: velocityX < 0,\n    movingTop: velocityY < 0,\n    movingRight: velocityX > 0,\n    movingBottom: velocityY > 0,\n  }\n}\n\nexport const getCollisionLeftLength = (blocA, blocB) => {\n  const blocALeft = blocA.positionX\n  const blocBLeft = blocB.positionX\n  const blocBRight = blocBLeft + blocB.width\n  const collisionLeftLength =\n    blocALeft < blocBRight && blocALeft > blocBLeft ? blocALeft - blocBRight : 0\n\n  return collisionLeftLength\n}\n\nexport const getCollisionTopLength = (blocA, blocB) => {\n  const blocATop = blocA.positionY\n  const blocBTop = blocB.positionY\n  const blocBBottom = blocBTop + blocB.height\n  const collisionTopLength =\n    blocATop < blocBBottom && blocATop > blocBTop ? blocATop - blocBBottom : 0\n\n  return collisionTopLength\n}\n\nexport const getCollisionRightLength = (blocA, blocB) => {\n  const blocALeft = blocA.positionX\n  const blocARight = blocALeft + blocA.width\n  const blocBLeft = blocB.positionX\n  const blocBRight = blocBLeft + blocB.width\n  const collisionRightLength =\n    blocARight > blocBLeft && blocARight < blocBRight ? blocARight - blocBLeft : 0\n\n  return collisionRightLength\n}\n\nexport const getCollisionBottomLength = (blocA, blocB) => {\n  const blocATop = blocA.positionY\n  const blocABottom = blocATop + blocA.height\n  const blocBTop = blocB.positionY\n  const blocBBottom = blocBTop + blocB.height\n  const collisionBottomLength =\n    blocABottom > blocBTop && blocABottom < blocBBottom ? blocABottom - blocBTop : 0\n\n  return collisionBottomLength\n}\n\n// https://github.com/liabru/matter-js/issues/5\n// http://www.stencyl.com/help/view/continuous-collision-detection\nexport const blocEffectCollisionResolutionBounce = {\n  \"collision-resolution-bounce\": (bloc) => {\n    bloc.blocCollidingArray.forEach((blocColliding) => {\n      const { collisionSpeed, collisionVectorNormalized } = getCollisionImpact(bloc, blocColliding)\n\n      const impulse = (2 * collisionSpeed) / (bloc.mass + blocColliding.mass)\n      mutateBloc(bloc, {\n        velocityX: bloc.velocityX - impulse * blocColliding.mass * collisionVectorNormalized.x,\n        velocityY: bloc.velocityY - impulse * blocColliding.mass * collisionVectorNormalized.y,\n      })\n      mutateBloc(blocColliding, {\n        velocityX: blocColliding.velocityX + impulse * bloc.mass * collisionVectorNormalized.x,\n        velocityY: blocColliding.velocityY + impulse * bloc.mass * collisionVectorNormalized.y,\n      })\n    })\n  },\n}\n\nexport const getCollisionImpact = (blocA, blocB) => {\n  const blocACenterPoint = blocToCenterPoint(blocA)\n  const blocBCenterPoint = blocToCenterPoint(blocB)\n\n  const collisionVector = {\n    x: blocBCenterPoint.x - blocACenterPoint.x,\n    y: blocBCenterPoint.y - blocACenterPoint.y,\n  }\n  const distanceBetweenBlocs = getDistanceBetweenTwoPoints(blocBCenterPoint, blocACenterPoint)\n  const collisionVectorNormalized = {\n    x: collisionVector.x / distanceBetweenBlocs,\n    y: collisionVector.y / distanceBetweenBlocs,\n  }\n  const velocityRelativeVector = {\n    x: blocA.velocityX - blocB.velocityX,\n    y: blocA.velocityY - blocB.velocityY,\n  }\n  let speed =\n    velocityRelativeVector.x * collisionVectorNormalized.x +\n    velocityRelativeVector.y * collisionVectorNormalized.y\n  speed *= Math.min(blocA.restitution, blocB.restitution)\n\n  return {\n    collisionSpeed: speed,\n    collisionVectorNormalized,\n  }\n}\n\nexport const blocEffectCollisionResolutionFriction = {\n  \"collision-resolution-friction\": () => {},\n}\n",
    "import { Bloc, mutateBloc } from \"./bloc.js\"\nimport { blocEffectContainer } from \"./bloc.effects.js\"\n\nexport const createGame = ({\n  worldContainer = false,\n  drawAfterUpdate = false,\n  rowCount,\n  columnCount,\n  cellSize = 32,\n  worldMagneticGrid = false,\n  blocs,\n} = {}) => {\n  const width = rowCount * cellSize\n  const height = columnCount * cellSize\n  const canvas = createCanvas({\n    width,\n    height,\n  })\n  const context = canvas.getContext(\"2d\")\n\n  const blocForWorld = {\n    ...Bloc,\n    name: \"world\",\n    updates: {\n      ...(worldMagneticGrid\n        ? {\n            \"magnetic-grid\": (world, { blocs }) => {\n              blocs.forEach((bloc) => {\n                if (!bloc.canMove) {\n                  return\n                }\n\n                const { velocityX, positionX } = bloc\n                const closestRowX = Math.round(positionX / cellSize) * cellSize\n                const xDiff = positionX - closestRowX\n\n                // x n'est pas sur la colonne et suffisament proche de celle ci\n                // et se déplace suffisament lentement\n                console.log(xDiff, velocityX)\n                if (xDiff && Math.abs(xDiff) < 5 && Math.abs(velocityX) < 5) {\n                  // le bloc est a gauche de la colonne la plus proche\n                  if (xDiff < 0) {\n                    console.log(\"attire vers la droite\", {\n                      positionX,\n                      closestRowX,\n                    })\n                    bloc.velocityX = 50\n                  }\n                  // le bloc est a droite\n                  if (xDiff > 0) {\n                    console.log(\"attire vers la gauche\", {\n                      positionX,\n                      closestRowX,\n                    })\n                    bloc.velocityX = -50\n                  }\n                }\n              })\n            },\n          }\n        : {}),\n    },\n    effects: {\n      ...(worldContainer ? blocEffectContainer : {}),\n    },\n    positionX: 0,\n    positionY: 0,\n    width,\n    height,\n    restitution: 0,\n  }\n  // on veut que la collision du monde se passe a la fin\n  // et on est dépendant de cela actuellement\n  // ce qui est pas fou\n  // il faudrait plutot que chaque bloc s'impose cela\n  // plutot que de compter sur ce truc\n  blocs.push(blocForWorld)\n\n  const tickCallbacks = []\n  const tick = (msEllapsed) => {\n    tickCallbacks.forEach((tickCallback) => {\n      tickCallback(msEllapsed)\n    })\n\n    blocs.forEach((bloc) => {\n      Object.keys(bloc.updates).forEach((key) => {\n        mutateBloc(bloc, bloc.updates[key](bloc, { blocs, msEllapsed }))\n      })\n    })\n    if (drawAfterUpdate) {\n      draw()\n    }\n    blocs.forEach((bloc) => {\n      Object.keys(bloc.effects).forEach((key) => {\n        mutateBloc(bloc, bloc.effects[key](bloc, { blocs, msEllapsed }))\n      })\n    })\n\n    draw()\n  }\n\n  const draw = () => {\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    const blocSorted = [...blocs].sort((leftBloc, rightBloc) => {\n      if (leftBloc.zIndex > rightBloc.zIndex) {\n        return 1\n      }\n      if (leftBloc.zIndex < rightBloc.zIndex) {\n        return -1\n      }\n      if (leftBloc.positionY > rightBloc.positionY) {\n        return 1\n      }\n      if (leftBloc.positionY < rightBloc.positionY) {\n        return -1\n      }\n      if (leftBloc.positionX > rightBloc.positionX) {\n        return 1\n      }\n      if (leftBloc.positionX < rightBloc.positionX) {\n        return -1\n      }\n      return 0\n    })\n    blocSorted.forEach((bloc) => {\n      bloc.draw(bloc, context)\n    })\n  }\n\n  let animationFrame\n  let started = false\n\n  const stop = () => {\n    started = false\n    window.cancelAnimationFrame(animationFrame)\n  }\n\n  const start = () => {\n    if (started) return\n    started = true\n\n    tick(0)\n    let msPrevious = performance.now()\n\n    const next = () => {\n      if (!started) {\n        return\n      }\n      animationFrame = window.requestAnimationFrame(() => {\n        const msNow = performance.now()\n        const msEllapsed = msNow - msPrevious\n        msPrevious = msNow\n        tick(msEllapsed)\n        next()\n      })\n    }\n\n    next()\n  }\n\n  const blocsFromPoint = ({ x, y }) => {\n    return blocs.filter((unit) => {\n      return context.isPointInPath(unit.path, x, y)\n    })\n  }\n\n  return {\n    canvas,\n    start,\n    stop,\n    draw,\n    blocsFromPoint,\n    addTickCallback: (callback) => {\n      tickCallbacks.push(callback)\n    },\n  }\n}\n\nconst createCanvas = ({ width, height }) => {\n  const canvas = document.createElement(\"canvas\")\n  canvas.width = width\n  canvas.height = height\n  return canvas\n}\n",
    "export const blocUpdateAcceleration = {\n  acceleration: ({ accelerationX, accelerationY }, { msEllapsed }) => {\n    const secondsEllapsed = msEllapsed / 1000\n\n    return {\n      velocityX: accelerationX * secondsEllapsed,\n      velocityY: accelerationY * secondsEllapsed,\n    }\n  },\n}\n\n// https://codepen.io/OliverBalfour/post/implementing-velocity-acceleration-and-friction-on-a-canvas\nexport const blocUpdateFriction = {\n  friction: ({ velocityX, velocityY, friction }) => {\n    const frictionCoef = 1 - friction\n    return {\n      velocityX: Math.round(velocityX * frictionCoef),\n      velocityY: Math.round(velocityY * frictionCoef),\n    }\n  },\n}\n\n// export const blocUpdateFriction = {\n//   friction: ({ velocityX, velocityY, friction }) => {\n//     let speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY)\n//     const angle = Math.atan2(velocityY, velocityX)\n//     if (speed > friction) {\n//       speed -= friction\n//     } else {\n//       speed = 0\n//     }\n//     return {\n//       velocityX: Math.cos(angle) * speed,\n//       velocityY: Math.sin(angle) * speed,\n//     }\n//   },\n// }\n\nexport const blocUpdateVelocity = {\n  velocity: ({ velocityX, velocityY, positionX, positionY }, { msEllapsed }) => {\n    const secondsEllapsed = msEllapsed / 1000\n\n    return {\n      positionX: Math.round(positionX + velocityX * secondsEllapsed),\n      positionY: Math.round(positionY + velocityY * secondsEllapsed),\n    }\n  },\n}\n",
    "export const CELL_SIZE = 32\n",
    "export const addDOMEventListener = (node, eventName, callback, options) => {\n  node.addEventListener(eventName, callback, options)\n  return () => {\n    node.removeEventListener(eventName, callback, options)\n  }\n}\n",
    "import { addDOMEventListener } from \"src/helper/dom.js\"\n\nexport const trackKeyboardKeydown = ({ node, code, onpress = () => {}, onrelease = () => {} }) => {\n  const key = {\n    isDown: false,\n  }\n\n  const removeKeydownListener = addDOMEventListener(node, \"keydown\", (keydownEvent) => {\n    if (keydownEvent.code !== code) {\n      return\n    }\n    keydownEvent.preventDefault()\n    if (!key.isDown) {\n      key.isDown = true\n      onpress()\n    }\n  })\n\n  const removeKeyupListener = addDOMEventListener(node, \"keyup\", (keyupEvent) => {\n    if (keyupEvent.code !== code) {\n      return\n    }\n    keyupEvent.preventDefault()\n    if (key.isDown) {\n      key.isDown = false\n      onrelease()\n    }\n  })\n\n  key.untrack = () => {\n    removeKeydownListener()\n    removeKeyupListener()\n  }\n\n  return key\n}\n",
    "/* eslint-disable no-nested-ternary */\n\n/*\n\npartons sur un truc méga simple niveau map genre du niveau de\nMystic quest legend (https://www.youtube.com/watch?v=Qlzd_fzUCdA)\nqui au final se jouait tres bien malgré un system de carte et déplacement\nsimplissime\n\nhttps://github.com/dmail-front/autotile\n- context api: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\nhttps://github.com/ovalia/ovalia/blob/master/html/game.html\nhttps://developers.google.com/web/updates/2018/08/offscreen-canvas\nhttps://developer.mozilla.org/en-US/docs/Games\n\nProchaines choses a faire:\n- Faciliter les déplacement pixel perfect dans la grille\nLorsqu'un élement se déplace, on va faciliter le fait qu'il s'arette pixel perfect dans la grille\ngenre s'il s'arette a 4px du bord d'une cellule il va continuer de glisser jusqu'a ce bord\n\nPtet en \"aimantant\" les arrete de la grille\n(tout objet déplacable est attiré vers cette grille (la grill lui confere une velocité))\n\n- Avoir un menu en bas de l'écran\nCe menu peut avoir un élement actif\nOn click dessus pour l'activer/désactiver\n\n- Pouvoir passer en mode édition (un bouton dans le menu)\ndans ce mode on sélectionne le type de chose qu'on veut modifier\non commence par sélectionner si on veut un sol/mur\nlorsqu'on clique quelque part, ce sol/mur actif remplace l'existant\n\n- Avoir un/des objet piece qu'on peut ramasser, il s'affiche dans le menu\n- Pouvoir ramasser une hache\n- Pouvoir équiper/déséquipper la hache\n- La hache permet de couper des arbres\n- Lorsqu'on clique sur le héros cela active l'action actuelle (hache)\n- Pouvoir faire un tunnel avec toit semi-transparent\n- Faire un escalier montant/descendant\n- Pouvoir faire un pont, on passe au dessus de quelque chose, mais aussi possible de passer en dessous\n\n*/\n\nimport { createGame } from \"src/game/game.js\"\nimport { Bloc, mutateBloc } from \"src/game/bloc.js\"\nimport { blocUpdateFriction, blocUpdateVelocity } from \"src/game/bloc.updates.js\"\nimport {\n  blocEffectCollisionDetection,\n  blocEffectCollisionResolution,\n  blocCollidingArrayGetter,\n  getCollisionLeftLength,\n  getCollisionTopLength,\n  getCollisionRightLength,\n  getCollisionBottomLength,\n  blocToMoveDirection,\n} from \"src/game/bloc.effects.js\"\nimport { CELL_SIZE } from \"src/game.constant.js\"\nimport { trackKeyboardKeydown } from \"src/interaction/keyboard.js\"\n\nwindow.splashscreen.remove()\n\nconst cellToRectangleGeometry = ({ row, column }) => {\n  return {\n    positionX: column * CELL_SIZE,\n    positionY: row * CELL_SIZE,\n    width: CELL_SIZE,\n    height: CELL_SIZE,\n  }\n}\n\nconst createFloorAtCell = ({ row, column }) => {\n  return {\n    ...Bloc,\n    name: \"floor\",\n    ...cellToRectangleGeometry({ row, column }),\n    fillStyle: \"white\",\n  }\n}\n\nconst createWallAtCell = ({ row, column, ...rest }) => {\n  return {\n    ...Bloc,\n    name: \"wall\",\n    zIndex: 1,\n    canCollide: true,\n    ...cellToRectangleGeometry({ row, column }),\n    fillStyle: \"grey\",\n    ...rest,\n  }\n}\n\nconst createBarilAtCell = ({ row, column, ...rest }) => {\n  return {\n    ...Bloc,\n    name: \"baril\",\n    mass: 100,\n    friction: 0.6,\n    canCollide: true,\n    canMove: true,\n    updates: {\n      ...blocUpdateFriction,\n      ...blocUpdateVelocity,\n    },\n    effects: {\n      ...blocEffectCollisionDetection,\n      ...blocEffectCollisionResolution,\n    },\n    ...cellToRectangleGeometry({ row, column }),\n    zIndex: 1,\n    fillStyle: \"brown\",\n    ...rest,\n  }\n}\n\nconst blocs = [\n  createFloorAtCell({ row: 0, column: 0 }),\n  createFloorAtCell({ row: 1, column: 0 }),\n  createFloorAtCell({ row: 2, column: 0 }),\n  createWallAtCell({ row: 0, column: 1 }),\n  createWallAtCell({ row: 1, column: 1 }),\n  createFloorAtCell({ row: 2, column: 1 }),\n  createWallAtCell({ row: 0, column: 2 }),\n  createFloorAtCell({ row: 1, column: 2 }),\n  createFloorAtCell({ row: 2, column: 2 }),\n\n  createWallAtCell({ row: 3, column: 3 }),\n  createWallAtCell({ row: 3, column: 4 }),\n  createWallAtCell({ row: 3, column: 1 }),\n  createWallAtCell({ row: 4, column: 3 }),\n  createWallAtCell({ row: 4, column: 4 }),\n  createWallAtCell({ row: 0, column: 5 }),\n\n  createBarilAtCell({ row: 2, column: 1 }),\n  createWallAtCell({ row: 0, column: 3 }),\n\n  createWallAtCell({ row: 6, column: 1 }),\n  createWallAtCell({ row: 6, column: 2 }),\n  createWallAtCell({ row: 6, column: 3 }),\n]\n\nconst cellFromPoint = ({ x, y }) => {\n  return {\n    x: Math.floor(x / CELL_SIZE) * CELL_SIZE,\n    y: Math.floor(y / CELL_SIZE) * CELL_SIZE,\n  }\n}\n\nconst game = createGame({\n  // drawAfterUpdate: true,\n  worldContainer: true,\n  rowCount: 7,\n  columnCount: 7,\n  cellSize: 32,\n  blocs,\n})\ndocument.body.appendChild(game.canvas)\n\ngame.start()\n\nconst downKey = trackKeyboardKeydown({\n  code: \"ArrowDown\",\n  node: game.canvas,\n})\nconst upKey = trackKeyboardKeydown({\n  code: \"ArrowUp\",\n  node: game.canvas,\n})\nconst leftKey = trackKeyboardKeydown({\n  code: \"ArrowLeft\",\n  node: game.canvas,\n})\nconst rightKey = trackKeyboardKeydown({\n  code: \"ArrowRight\",\n  node: game.canvas,\n})\n\nconst createHeroAtCell = ({ row, column }) => {\n  const hero = {\n    ...Bloc,\n    name: \"hero\",\n    canCollide: true,\n    canMove: true,\n    friction: 0.5,\n    zIndex: 1,\n    mass: 10,\n    keyboardVelocity: 100,\n    updates: {\n      ...blocUpdateFriction,\n      keyboardNavigation: ({ velocityX, velocityY, keyboardVelocity }) => {\n        const velocityXNew = leftKey.isDown\n          ? -keyboardVelocity\n          : rightKey.isDown\n          ? keyboardVelocity\n          : velocityX\n        const velocityYNew = upKey.isDown\n          ? -keyboardVelocity\n          : downKey.isDown\n          ? keyboardVelocity\n          : velocityY\n\n        return {\n          velocityX: velocityXNew,\n          velocityY: velocityYNew,\n        }\n      },\n      ...blocUpdateVelocity,\n    },\n    effects: {\n      ...blocEffectCollisionDetection,\n      \"push-baril\": (hero) => {\n        hero.blocCollidingArray.forEach((blocColliding) => {\n          if (blocColliding.name !== \"baril\") {\n            return\n          }\n          // no dialognal move allowed\n          if (hero.velocityX && hero.velocityY) {\n            return\n          }\n          const baril = blocColliding\n          const { movingLeft, movingTop, movingRight, movingBottom } = blocToMoveDirection(hero)\n          if (movingLeft && getCollisionLeftLength(hero, baril)) {\n            mutateBloc(baril, {\n              velocityX: baril.velocityX + hero.velocityX,\n            })\n          }\n          if (movingTop && getCollisionTopLength(hero, baril)) {\n            mutateBloc(baril, {\n              velocityY: baril.velocityY + hero.velocityY,\n            })\n          }\n          if (movingRight && getCollisionRightLength(hero, baril)) {\n            mutateBloc(baril, {\n              velocityX: baril.velocityX + hero.velocityX,\n            })\n          }\n          if (movingBottom && getCollisionBottomLength(hero, baril)) {\n            mutateBloc(baril, {\n              velocityY: baril.velocityY + hero.velocityY,\n            })\n          }\n        })\n      },\n      ...blocEffectCollisionResolution,\n    },\n    ...cellToRectangleGeometry({ row, column }),\n    width: 24,\n    height: 24,\n    fillStyle: \"red\",\n  }\n  return hero\n}\n\nconst hero = createHeroAtCell({ row: 0, column: 0 })\nblocs.push(hero)\n\ngame.canvas.addEventListener(\"click\", (clickEvent) => {\n  const clickPoint = {\n    x: clickEvent.offsetX,\n    y: clickEvent.offsetY,\n  }\n  const destinationPoint = cellFromPoint(clickPoint)\n  moveBlocIfAllowed(hero, {\n    positionX: destinationPoint.x,\n    positionY: destinationPoint.y,\n  })\n})\ngame.canvas.setAttribute(\"tabindex\", -1)\n\nconst moveBlocIfAllowed = (bloc, { positionX = bloc.positionX, positionY = bloc.positionY }) => {\n  const currentPosition = {\n    positionX: bloc.positionX,\n    positionY: bloc.positionY,\n  }\n  mutateBloc(bloc, { positionX, positionY })\n  const blocCollidingArray = blocCollidingArrayGetter(bloc, blocs)\n  if (blocCollidingArray.length > 0) {\n    mutateBloc(bloc, currentPosition)\n  }\n}\n\nconst buttonPause = document.createElement(\"button\")\nbuttonPause.innerHTML = \"pause\"\nbuttonPause.onclick = () => {\n  game.stop()\n}\nconst buttonPlay = document.createElement(\"button\")\nbuttonPlay.innerHTML = \"play\"\nbuttonPlay.onclick = () => {\n  game.start()\n}\n\ndocument.body.appendChild(document.createElement(\"br\"))\ndocument.body.appendChild(buttonPause)\ndocument.body.appendChild(buttonPlay)\n\nwindow.game = game\nwindow.blocs = blocs\n"
  ],
  "names": [
    "listenEvent",
    "objectWithEventEmitter",
    "event",
    "callback",
    "addEventListener",
    "removeEventListener",
    "displayModeStandalone",
    "window",
    "navigator",
    "standalone",
    "matchMedia",
    "matches",
    "media",
    "addListener",
    "removeListener",
    "f",
    "promptAddToHomescreen",
    "beforeinstallpromptEvent",
    "prompt",
    "value",
    "userChoice",
    "then",
    "choiceResult",
    "outcome",
    "direct",
    "Promise",
    "resolve",
    "console",
    "warn",
    "args",
    "i",
    "arguments",
    "length",
    "apply",
    "this",
    "e",
    "reject",
    "beforeinstallpromptEventAvailableOnWindowGetter",
    "Boolean",
    "addToHomescreenAvailableGetter",
    "beforeinstallpromptEventAvailableOnWindow",
    "displayModeIsStandalone",
    "appInstalledEvent",
    "listenBeforeInstallPrompt",
    "arrayLikeToArray",
    "arr",
    "len",
    "arr2",
    "Array",
    "isArray",
    "arrayWithoutHoles",
    "iter",
    "Symbol",
    "iterator",
    "Object",
    "from",
    "iterableToArray",
    "o",
    "minLen",
    "n",
    "prototype",
    "toString",
    "call",
    "slice",
    "constructor",
    "name",
    "test",
    "unsupportedIterableToArray",
    "TypeError",
    "nonIterableSpread",
    "_await",
    "serviceWorkerAPI",
    "serviceWorker",
    "body",
    "result",
    "listeners",
    "canUseServiceWorker",
    "document",
    "location",
    "protocol",
    "registrationPromise",
    "serviceWorkerUpdating",
    "serviceWorkerUpdatingChangeSignal",
    "listen",
    "once",
    "callbackOriginal",
    "stopListening",
    "removed",
    "listenersWithoutCallback",
    "searching",
    "listenerCandidate",
    "push",
    "emit",
    "forEach",
    "listener",
    "serviceWorkerUpdatingSetter",
    "worker",
    "log",
    "state",
    "checkServiceWorkerUpdate",
    "registration",
    "update",
    "updateRegistration",
    "installing",
    "waiting",
    "sendMessageToServiceWorkerUpdate",
    "message",
    "objectWithPostMessage",
    "MessageChannel",
    "port1",
    "port2",
    "onmessage",
    "data",
    "status",
    "postMessage",
    "sendMessageUsingChannel",
    "activateServiceWorkerUpdate",
    "params",
    "Error",
    "sendSkipWaitingToWorker",
    "onActivating",
    "onActivated",
    "onBecomesNavigatorController",
    "waitUntilActivated",
    "removeStateChangeListener",
    "action",
    "controller",
    "removeControllerChangeListener",
    "reload",
    "autoReloadEnabled",
    "refreshing",
    "createDOM",
    "stringContainingHTMLSource",
    "DOMParser",
    "parseFromString",
    "buttonAddToHomescreen",
    "querySelector",
    "appendChild",
    "onclick",
    "availablePrevious",
    "checkAvailable",
    "available",
    "removeBeforeInstallPromptListener",
    "removeDisplayModeListener",
    "removeAppInstalledListener",
    "listenAppInstalled",
    "listenAddToHomescreenAvailable",
    "disabled",
    "requestIdleCallback",
    "requestAnimationFrame",
    "url",
    "scope",
    "unregistered",
    "unregister",
    "removeUpdateFoundListener",
    "register",
    "active",
    "registerServiceWorker",
    "serviceWorkerUpdateDocument",
    "buttonCheckUpdate",
    "paragraph",
    "innerHTML",
    "found",
    "shouldBecomeNavigatorController",
    "navigatorWillReload",
    "_call",
    "source",
    "excluded",
    "key",
    "target",
    "sourceKeys",
    "keys",
    "indexOf",
    "objectWithoutPropertiesLoose",
    "getOwnPropertySymbols",
    "sourceSymbolKeys",
    "propertyIsEnumerable",
    "obj",
    "defineProperty",
    "enumerable",
    "configurable",
    "writable",
    "ownKeys",
    "getOwnPropertyDescriptors",
    "defineProperties",
    "getOwnPropertyDescriptor",
    "object",
    "enumerableOnly",
    "symbols",
    "filter",
    "sym",
    "applyStyle",
    "context",
    "alpha",
    "fillStyle",
    "strokeStyle",
    "image",
    "imageSourceX",
    "imageSourceY",
    "positionX",
    "positionY",
    "width",
    "height",
    "globalAlpha",
    "fill",
    "stroke",
    "clip",
    "drawImage",
    "restore",
    "Bloc",
    "zIndex",
    "blocCollidingArray",
    "canCollide",
    "accelerationX",
    "accelerationY",
    "velocityX",
    "velocityY",
    "friction",
    "restitution",
    "mass",
    "undefined",
    "updates",
    "effects",
    "draw",
    "bloc",
    "beginPath",
    "rect",
    "closePath",
    "mutateBloc",
    "mutations",
    "assign",
    "blocToCenterPoint",
    "x",
    "y",
    "rectangleCollidesRectangle",
    "firstRectangle",
    "secondRectangle",
    "firstLeft",
    "firstRight",
    "secondLeft",
    "firstTop",
    "firstBottom",
    "secondTop",
    "blocEffectCollisionDetection",
    "blocs",
    "blocCollidingArrayGetter",
    "blocCandidate",
    "secondBloc",
    "firstBloc",
    "blocEffectContainer",
    "container",
    "blocContainer",
    "blocLeft",
    "blocWidth",
    "blocRight",
    "blocTop",
    "blocHeight",
    "blocBottom",
    "containerLeft",
    "containerTop",
    "containerRight",
    "containerBottom",
    "containerRestitution",
    "blocMutations",
    "Math",
    "abs",
    "blocEffectCollisionResolution",
    "blocColliding",
    "blocCenterPoint",
    "blocCollidingCenterPoint",
    "centerXDiff",
    "centerYDiff",
    "ww2",
    "hh2",
    "oX",
    "oY",
    "createCanvas",
    "canvas",
    "createElement",
    "blocUpdateFriction",
    "frictionCoef",
    "round",
    "blocUpdateVelocity",
    "velocity",
    "secondsEllapsed",
    "msEllapsed",
    "CELL_SIZE",
    "addDOMEventListener",
    "node",
    "eventName",
    "options",
    "trackKeyboardKeydown",
    "code",
    "onpress",
    "onrelease",
    "isDown",
    "removeKeydownListener",
    "keydownEvent",
    "preventDefault",
    "removeKeyupListener",
    "keyupEvent",
    "untrack",
    "splashscreen",
    "remove",
    "row",
    "column",
    "rest",
    "cellToRectangleGeometry",
    "createFloorAtCell",
    "createWallAtCell",
    "canMove",
    "game",
    "worldContainer",
    "drawAfterUpdate",
    "rowCount",
    "columnCount",
    "cellSize",
    "worldMagneticGrid",
    "getContext",
    "blocForWorld",
    "world",
    "closestRowX",
    "xDiff",
    "animationFrame",
    "tickCallbacks",
    "tick",
    "tickCallback",
    "clearRect",
    "_toConsumableArray",
    "sort",
    "leftBloc",
    "rightBloc",
    "started",
    "stop",
    "cancelAnimationFrame",
    "start",
    "msPrevious",
    "performance",
    "now",
    "next",
    "msNow",
    "blocsFromPoint",
    "unit",
    "isPointInPath",
    "path",
    "addTickCallback",
    "createGame",
    "downKey",
    "upKey",
    "leftKey",
    "rightKey",
    "hero",
    "keyboardVelocity",
    "keyboardNavigation",
    "blocB",
    "blocALeft",
    "blocBLeft",
    "blocBRight",
    "baril",
    "movingLeft",
    "movingTop",
    "movingRight",
    "movingBottom",
    "blocA",
    "blocATop",
    "blocBTop",
    "blocBBottom",
    "getCollisionTopLength",
    "blocARight",
    "getCollisionRightLength",
    "blocABottom",
    "getCollisionBottomLength",
    "createHeroAtCell",
    "clickEvent",
    "clickPoint",
    "offsetX",
    "offsetY",
    "destinationPoint",
    "floor",
    "moveBlocIfAllowed",
    "setAttribute",
    "currentPosition",
    "buttonPause",
    "buttonPlay"
  ],
  "mappings": "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"
}